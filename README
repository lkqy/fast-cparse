以_, a~z 开头的token为变量(c语言变量定义规范)
以A~Z 开头的token为函数

这个实现主要解决高性能场景下的动态求值，目前只支持特定类型的操作。
1、+ - * / % => 仅限int long float double
2、and or not => 仅限 bool 类型
3、> >= == < <= 仅限int long float double string
4、in => vector, map, string
5、function 调用, 参数为1， 2， 3, 返回值为ValuePtr类型
6、内置VEC、SET函数，用于初始化常量数组、集合
7、线程安全
8、变量自动类型提升int -> long -> float -> double, 如果最终求值类型和实际类型不一致，会强制类型转换



缺点：
1、为防止异常，特执行如下动作:
   对于不同类型之间的操作，如果是目标是bool结果，那么不同类型比较一律为false
                                  + - * / % in 等操作，保持左数
                                  VEC, SET 以第一个元素类型为标准，跳过不合法的类型
2、由于动态求值本身问题，输入数值、表达式一定要符合要求
3、函数调用只限于固定函数参数类型的求解

目前的性能瓶颈：
1、动态对象申请

使用方法:
    std::string exp("a < 7 and b < 4 and not c");
    ShuntingYard sy(exp);
    sy.compile();
    int t = 0;
    for (size_t i = 0; i < count; ++i) {
        std::vector<std::pair<const char*, Value*>> env = {
            std::make_pair<const char*, Value*>("a",  new LongValue(i%7)),
            std::make_pair<const char*, Value*>("b",  new LongValue(i%7)),
            std::make_pair<const char*, Value*>("c",  new BoolValue(false)),
        };
        std::string log;
        t+= sy.eval_bool(env, log); //传入的env指针会自动释放，目前没有考虑指针重复问题，传入时需谨慎
        // 要检查log是否为空(传入的数值类型不对会触发异常)
        assert(log.emtpy());
    }
    std::cout<<"parse  eval:"<<exp<<", loop:"<<t<<"\n";

上述例子的耗时为：count=1百万时，耗时653毫秒

TODO:
减少动态内存申请
